<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="smilenceee">


    <meta name="subtitle" content="to myself">




<title>logstash插件开发 | recording &amp; rethinking</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">TIME IN LVIH</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">TIME IN LVIH</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">logstash插件开发</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">smilenceee</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">January 10, 2015&nbsp;&nbsp;0:30:31</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>前一阵子，上线了<a target="_blank" rel="noopener" href="http://logstash.net/">logstash</a>来监视各个业务系统的日志，效果还不错，日志中暴露的问题总能及时发出报警邮件。不过，有个问题——当杀死<a target="_blank" rel="noopener" href="http://community.pentaho.com/projects/data-integration/">kettle</a>中的job或者某个job运行出错需要stop时，短时间内会产生大量重复的错误日志，由于当前采取的策略是，只要发现错误立刻发邮件，所以导致邮箱瞬间爆满，然后logstash与邮件服务器之间的链接出现问题，进程退出。对此，考虑这么几个方案：</p>
<ol>
<li>对于像stop job时频繁产生的错误，直接忽略，不发送邮件通知</li>
<li>缓存已经发送邮件的错误日志，如果在指定的时间内，重复发生，直接忽略</li>
<li>缓存出错的日志，当达到指定时间或者指定数目，发送邮件</li>
</ol>
<p>第一种方案简单，只需要修改配置文件即可，缺点是硬编码带来的灵活性缺失，且规则不好定义，若写成类似<code>if &quot;... try to stop transformation ...&quot; in [message]</code>这种，实在是ugly；<br>第二种方案和第三种方案共同之处在于缓存，不同之处在于缓存内容，前者缓存的是已发送邮件，策略是若发送过，忽略不再发送；后者缓存的是所有的日志，指定条件满足发送邮件。前者的优势在于邮件内容简洁，劣势是实现稍显复杂（对于没有ruby基础的人来说）。</p>
<p>权衡之下，选取了第三种方案。</p>
<p>下面会给出插件开发相关概念及大致流程，这部分内容翻译自logstash的官网给出的两份资料，对于其中不清楚的地方会结合我在使用中的情况补充说明，最后会给出第三种方案的思路和实现。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://logstash.net/docs/1.4.2/extending/">Extending logstash</a></li>
<li><a target="_blank" rel="noopener" href="http://logstash.net/docs/1.4.2/extending/example-add-a-new-filter">Add a new filter</a></li>
</ul>
<hr>
<p>logstash支持自定义input，output和filter插件。自己开发插件的时候，最好阅读现有插件的源码。</p>
<blockquote>
<p>这就是像我这种只看了两天ruby语法的newbie也可以写出插件的秘密所在</p>
</blockquote>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><code>config_name</code>配置文件中的插件名</li>
<li><code>milestone</code>插件开发阶段</li>
<li><code>config</code>配置项</li>
<li>插件初始化过程中会调用<code>register</code>方法。初始化可以在该方法中完成</li>
</ul>
<h3 id="require-模块"><a href="#require-模块" class="headerlink" title="require 模块"></a>require 模块</h3><p>所有插件都需要的模块</p>
<pre><code>require &#39;logstash/namespace&#39;
</code></pre>
<h3 id="插件名"><a href="#插件名" class="headerlink" title="插件名"></a>插件名</h3><p>每个插件都需要通过方法<code>config_name</code>设置一个插件名。如果没有指定，加载时会出错。</p>
<h3 id="milestones"><a href="#milestones" class="headerlink" title="milestones"></a>milestones</h3><p>略</p>
<h3 id="config-lines"><a href="#config-lines" class="headerlink" title="config lines"></a>config lines</h3><p>配置行定义了配置选项，形式如下：</p>
<pre><code>config :host, :validate =&gt; :string, :default =&gt; &quot;0.0.0.0&quot;
</code></pre>
<p>这里指定了选项名<code>:host</code>及其属性。他们是<code>:validate</code>，<code>:default</code>，<code>:required</code>(true 或者 false)以及<code>:deprecated</code>(boolean)。</p>
<h2 id="inputs"><a href="#inputs" class="headerlink" title="inputs"></a>inputs</h2><p>所有的inputs require类<code>LogStash::Inputs::Base</code></p>
<pre><code>require &#39;logstash/inputs/base&#39;
</code></pre>
<p>inputs需要实现的两个方法<code>:register</code>和<code>run</code>。</p>
<ul>
<li>每个input运行在自己的线程中</li>
<li>run方法需要持续运行</li>
</ul>
<h2 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h2><p>所有的filters require类<code>LogStash::Filters::Base</code></p>
<pre><code>require &#39;logstash/filters/base&#39;
</code></pre>
<p>filters需要实现两个方法：<code>register</code>和<code>filter</code>。</p>
<ul>
<li>方法<code>filter</code>接收一个event</li>
<li>调用<code>event.cancel</code>丢弃事件</li>
<li></li>
<li>忽略返回值</li>
</ul>
<h2 id="outputs"><a href="#outputs" class="headerlink" title="outputs"></a>outputs</h2><p>所有的outputs require类<code>LogStash::Outputs::Base</code></p>
<pre><code>require &#39;logstash/outputs/base&#39;
</code></pre>
<p>outputs需要实现两个方法：<code>register</code>和<code>receive</code></p>
<ul>
<li>插件初始化调用<code>register</code>方法。在这里可以做些初始化</li>
<li>每当output接收到event时调用<code>receive</code>方法</li>
</ul>
<h2 id="示例：自定义过滤器"><a href="#示例：自定义过滤器" class="headerlink" title="示例：自定义过滤器"></a>示例：自定义过滤器</h2><p>实现的功能就是将event中的message替换成字符串”Hello world!”。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>首先，插件需要放在指定的目录中：</p>
<pre><code>logstash/TYPE/PLUGIN_NAME.rb
</code></pre>
<p>因为这里实现的是filter，创建如下目录：</p>
<pre><code>mkdir -p logstash/filters/
cd logstash/filters
</code></pre>
<blockquote>
<p>我这里的目录结构如下：</p>
</blockquote>
<pre><code>├── logstash-1.4.2
│   ├── logstash
│   │   ├── filters
│   │   │   └── foo.rb
│   │   └── outputs
│   │       └── bufferEmail.rb
</code></pre>
<p>文件<code>foo.rb</code>实现如下：</p>
<pre><code># Call this file &#39;foo.rb&#39; (in logstash/filters, as above)
require &quot;logstash/filters/base&quot;
require &quot;logstash/namespace&quot;

class LogStash::Filters::Foo &lt; LogStash::Filters::Base

  # Setting the config_name here is required. This is how you
  # configure this filter from your logstash config.
  #
  # filter &#123;
  #   foo &#123; ... &#125;
  # &#125;
  config_name &quot;foo&quot;

  # New plugins should start life at milestone 1.
  milestone 1

  # Replace the message with this value.
  config :message, :validate =&gt; :string

  public
  def register
    # nothing to do
  end # def register

  public
  def filter(event)
    # return nothing unless there&#39;s an actual filter event
    return unless filter?(event)
    if @message
      # Replace the event message with our message as configured in the
      # config file.
      event[&quot;message&quot;] = @message
    end
    # filter_matched should go in the last line of our successful code 
    filter_matched(event)
  end # def filter
end # class LogStash::Filters::Foo
</code></pre>
<h3 id="在配置文件中使用"><a href="#在配置文件中使用" class="headerlink" title="在配置文件中使用"></a>在配置文件中使用</h3><p>作为示例，input和output分别是stdin和stdout。配置内容如下：</p>
<pre><code>input &#123; 
  stdin &#123; type =&gt; &quot;foo&quot; &#125; 
&#125;
filter &#123;
  if [type] == &quot;foo&quot; &#123;
    foo &#123;
      message =&gt; &quot;Hello world!&quot;
    &#125;
  &#125;
&#125;
output &#123;
  stdout &#123; &#125;
&#125;
</code></pre>
<h3 id="Tell-logstash-about-it"><a href="#Tell-logstash-about-it" class="headerlink" title="Tell logstash about it"></a>Tell logstash about it</h3><p>取决于logstash的安装方式，有多种方法引用插件。</p>
<p>可以使用<code>--pluginpath</code> flag指定插件根目录。在这里就是当前目录（从测试结果来看，还是需要显式指定）。</p>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>输入”Hello YX!”，输出”Hello world!”</p>
<pre><code>[root@dn5 logstash]# bin/logstash agent --verbose --pluginpath ./ -f conf/plugin_filter.conf 
...
Hello YX!
2015-01-09T14:56:12.084+0000 dn5 Hello World!
</code></pre>
<blockquote>
<p>尝试不显式指定插件目录，报错了</p>
<pre><code>[root@dn5 logstash]# bin/logstash agent --verbose  -f conf/plugin_filter.conf 
...
The error reported is: 
  Couldn\&#39;t find any filter plugin named &#39;foo&#39;. Are you sure this is correct? Trying to load the foo filter plugin resulted in this error: no such file to load -- logstash/filters/foo
</code></pre>
</blockquote>
<h2 id="output-email-with-buffer"><a href="#output-email-with-buffer" class="headerlink" title="output email with buffer"></a>output email with buffer</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>正如之前所言，动手实现插件之前，不妨看看现有的相关插件，于是翻阅了两个插件的源码，<a target="_blank" rel="noopener" href="https://github.com/elasticsearch/logstash/blob/v1.4.2/lib/logstash/outputs/redis.rb">redis</a>和<a target="_blank" rel="noopener" href="https://github.com/elasticsearch/logstash/blob/v1.4.2/lib/logstash/outputs/email.rb">email</a>。redis中通过<a target="_blank" rel="noopener" href="https://github.com/jordansissel/ruby-stud/blob/master/lib/stud/buffer.rb">buffer</a>实现了缓存逻辑，buffer是一个缓存框架，其实现了超时和计数两种缓存策略，当条件满足时，会调用用户提供的<code>flush</code>函数；email没啥好说（其实是没看懂）。说到这里思路已经很清晰了——在自己的<code>flush</code>函数中，调用email模块发送缓存的日志，代码如下。</p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><pre><code># encoding: utf-8
require &quot;logstash/outputs/base&quot;
require &quot;logstash/namespace&quot;
require &quot;logstash/event&quot;
require &quot;stud/buffer&quot;

# email output with buffer 
# author：fanhaiqiang
class LogStash::Outputs::BufferEmail &lt; LogStash::Outputs::Base

    include Stud::Buffer

    config_name &quot;bufferEmail&quot;
    milestone 1

    # The fully-qualified email address to send the email to.
    #
    # This field also accepts a comma-separated string of addresses, for example: 
    # &quot;me@host.com, you@host.com&quot;
    # 
    # You can also use dynamic fields from the event with the %&#123;fieldname&#125; syntax.
    config :to, :validate =&gt; :string, :required =&gt; true

    # The fully-qualified email address for the From: field in the email.
    config :from, :validate =&gt; :string, :default =&gt; &quot;logstash.alert@nowhere.com&quot;

    # The fully qualified email address for the Reply-To: field.
    config :replyto, :validate =&gt; :string

    # The fully-qualified email address(es) to include as cc: address(es).
    #
    # This field also accepts a comma-separated string of addresses, for example: 
    # &quot;me@host.com, you@host.com&quot;
    config :cc, :validate =&gt; :string

    # How Logstash should send the email, either via SMTP or by invoking sendmail.
    config :via, :validate =&gt; :string, :default =&gt; &quot;smtp&quot;

    config :options, :validate =&gt; :hash, :default =&gt; &#123;&#125;

    # Subject: for the email.
    config :subject, :validate =&gt; :string, :default =&gt; &quot;&quot;

    # Body for the email - plain text only.
    config :body, :validate =&gt; :string, :default =&gt; &quot;&quot;

    # HTML Body for the email, which may contain HTML markup.
    config :htmlbody, :validate =&gt; :string, :default =&gt; &quot;&quot;

    # Attachments - specify the name(s) and location(s) of the files.
    config :attachments, :validate =&gt; :array, :default =&gt; []

    # contenttype : for multipart messages, set the content-type and/or charset of the HTML part.
    # NOTE: this may not be functional (KH)
    config :contenttype, :validate =&gt; :string, :default =&gt; &quot;text/html; charset=UTF-8&quot;

    config :batch, :validate =&gt; :boolean, :default =&gt; true

    config :batch_events, :validate =&gt; :number, :default =&gt; 50

    config :batch_timeout, :validate =&gt; :number, :default =&gt; 5


    def register
        require &quot;mail&quot;

        # Mail uses instance_eval which changes the scope of self so @options is
        # inaccessible from inside &#39;Mail.defaults&#39;. So set a local variable instead.
        options = @options

        if @via == &quot;smtp&quot;
            Mail.defaults do
                delivery_method :smtp, &#123;
                    :address              =&gt; options.fetch(&quot;smtpIporHost&quot;, &quot;localhost&quot;),
                    :port                 =&gt; options.fetch(&quot;port&quot;, 25),
                    :domain               =&gt; options.fetch(&quot;domain&quot;, &quot;localhost&quot;),
                    :user_name            =&gt; options.fetch(&quot;userName&quot;, nil),
                    :password             =&gt; options.fetch(&quot;password&quot;, nil),
                    :authentication       =&gt; options.fetch(&quot;authenticationType&quot;, nil),
                    :enable_starttls_auto =&gt; options.fetch(&quot;starttls&quot;, false),
                    :debug                =&gt; options.fetch(&quot;debug&quot;, false)
                &#125;
            end
        elsif @via == &#39;sendmail&#39;
            Mail.defaults do
                delivery_method :sendmail
            end
        else
            Mail.defaults do
                delivery_method :@via, options
            end
        end # @via tests
        @logger.debug(&quot;Email Output Registered!&quot;, :config =&gt; @config)

        # 缓冲区初始化
        buffer_initialize(
            :max_items =&gt; @batch_events,
            :max_interval =&gt; @batch_timeout,
            :logger =&gt; @logger 
        )
    end # def register
    
    def receive(event)
        return unless output?(event) 
        #buffer_receive(event)
        #buffer_receive(event.to_json)
        buffer_receive(event.sprintf(&quot;%&#123;@timestamp&#125; %&#123;host&#125; %&#123;type&#125; %&#123;message&#125;&quot;))
    end # def receive

    # called from Stud::Buffer#buffer_flush when there are events to flush
    def flush(events, teardown=false)
        # 
        joinedEvent = LogStash::Event.new
        cnt = events.size
        @logger.debug? and @logger.debug(&quot;events size = &quot;, cnt)
        case cnt
        when 0
            return
        else 
            message = events.join(&quot;\n&quot;)
            joinedEvent[&quot;message&quot;] = message
         # events.each do |event|
         #   joinedEvent.append(event)
         # end
        end

        @logger.debug? and @logger.debug(&quot;Creating mail with these settings : &quot;, :via =&gt; @via, :options =&gt; @options, :from =&gt; @from, :to =&gt; @to, :cc =&gt; @cc, :subject =&gt; @subject, :body =&gt; @body, :content_type =&gt; @contenttype, :htmlbody =&gt; @htmlbody, :attachments =&gt; @attachments, :to =&gt; to, :to =&gt; to)

        formattedSubject = joinedEvent.sprintf(@subject)
        formattedBody = joinedEvent.sprintf(@body)
        formattedHtmlBody = joinedEvent.sprintf(@htmlbody)

        mail = Mail.new
        mail.from = joinedEvent.sprintf(@from)
        mail.to = joinedEvent.sprintf(@to)
        if @replyto
            mail.reply_to = joinedEvent.sprintf(@replyto)
        end
        mail.cc = joinedEvent.sprintf(@cc)

        mail.subject = formattedSubject  
        if @htmlbody.empty?
            formattedBody.gsub!(/\\n/, &quot;\n&quot;) # Take new line in the email
            mail.body = formattedBody
        else
            mail.text_part = Mail::Part.new do
                content_type &quot;text/plain; charset=UTF-8&quot;
                formattedBody.gsub!(/\\n/, &quot;\n&quot;)
                body formattedBody
            end
            mail.html_part = Mail::Part.new do
                content_type &quot;text/html; charset=UTF-8&quot;
                body formattedHtmlBody
            end
        end

        @attachments.each do |fileLocation|
            mail.add_file(fileLocation)
        end # end @attachments.each
        @logger.debug? and @logger.debug(&quot;Sending mail with these values : &quot;, :from =&gt; mail.from, :to =&gt; mail.to, :cc =&gt; mail.cc, :subject =&gt; mail.subject)
        mail.deliver!
    end # def flush

    # called from Stud::Buffer#buffer_flush when an error occurs
    def on_flush_error(e)
        @logger.warn(&quot;Failed to send backlog of events to email buffer&quot;,
            :exception =&gt; e,
            :backtrace =&gt; e.backtrace
        )
    end

    def teardown
            buffer_flush(:final =&gt; true)
    end

end
</code></pre>
<p>20150110@前海花园</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>smilenceee</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/logstash%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/">http://yoursite.com/logstash%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/logstash/"># logstash</a>
                    
                        <a href="/tags/plugin/"># plugin</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/%E4%BD%BF%E7%94%A8ES%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90/">使用ES实现异常日志实时分析</a>
            
            
            <a class="next" rel="next" href="/hexo%E6%97%A5%E5%BF%97%E5%8E%9F%E5%A7%8B%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/">hexo日志原始文件管理</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© smilenceee | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>
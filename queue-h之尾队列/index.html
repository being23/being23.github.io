<!DOCTYPE html>
<html lang="">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="smilenceee">


    <meta name="subtitle" content="to myself">




<title>queue.h之尾队列 | recording &amp; rethinking</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">TIME IN LVIH</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">TIME IN LVIH</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">queue.h之尾队列</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">smilenceee</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">October 20, 2014&nbsp;&nbsp;20:54:24</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>之前看<a href="">librdkafka</a>和<a href="">libevhtp</a>的源码，发现其中大量使用<code>queue.h</code>定义的队列操作宏，于是学习了其中的尾队列，对应的系统版本是</p>
<pre><code>[root@datanode1 src]# cat /etc/redhat-release       
CentOS release 5.10 (Final)
</code></pre>
<hr>
<p>尾队好处是列增了一个指向上一个元素的指针，使得其在删除元素的时候不必遍历整个链表，同时支持反向遍历。</p>
<h3 id="头："><a href="#头：" class="headerlink" title="头："></a>头：</h3><pre><code>#define _TAILQ_HEAD(name, type, qual)
struct name &#123;
        qual type *tqh_first;           /* 指向第一个元素 */
        qual type *qual *tqh_last;      /* 指向最后一个元素的next指针 */
&#125;
#define TAILQ_HEAD(name, type)  _TAILQ_HEAD(name, struct type,)
</code></pre>
<blockquote>
<p>下文中用HEAD表示</p>
</blockquote>
<h3 id="域："><a href="#域：" class="headerlink" title="域："></a>域：</h3><pre><code>#define _TAILQ_ENTRY(type, qual)
struct &#123;
        qual type *tqe_next;            /* 指向下一个元素 */
        qual type *qual *tqe_prev;      /* 指向上一个元素的next指针 */
&#125;
#define TAILQ_ENTRY(type)       _TAILQ_ENTRY(struct type,)
</code></pre>
<blockquote>
<p>下文中用ENTRY表示</p>
</blockquote>
<p>这四个指针之间的关系是这样的——</p>
<ol>
<li><code>tqh_first</code><strong>指向头元素</strong>。当队列为空时，头元素就是HEAD，<code>tqh_first</code>相当于<code>tqe_next</code></li>
<li><code>tqh_last</code>指向尾元素的<code>tqe_next</code>指针，下文中简称为<strong>指向尾元素</strong>，所以是二级指针。当队列为空时，尾元素就是HEAD，它没有<code>tqe_next</code>指针，所以代之以<code>tqh_first</code>指针</li>
<li><code>tqe_next</code><strong>指向下一个元素</strong></li>
<li><code>tqe_prev</code>指向上一个元素的<code>tqe_next</code>指针，下文中简称为<strong>指向上一个元素</strong>，所以是二级指针。不过，头元素的上一个元素是HEAD，它没有<code>tqe_next</code>指针，所以代之以<code>tqh_first</code>指针</li>
</ol>
<p>说了这么多，一图以蔽之：<br><img src="/tail_queue.png" alt="Alt text"></p>
<blockquote>
<p>这里与查阅的参考文献（<a target="_blank" rel="noopener" href="http://blog.linuxphp.org/archives/1485/">C语言之尾队列tailq</a>）有一个区别，那就是头元素的<code>tqe_prev</code>指针是指向了HEAD的<code>tqh_first</code>，而非NULL。因为在宏<code>TAILQ_INSERT_HEAD</code>中，代码行<code>(elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first</code>清晰的说明了元素<code>elm</code>的<code>tqe_prev</code>指针指向了HEAD的<code>tqh_first</code>指针。</p>
</blockquote>
<h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><pre><code>#define TAILQ_INIT(head) do &#123;
        //头元素为NULL
        (head)-&gt;tqh_first = NULL;
        //尾元素是HEAD
        (head)-&gt;tqh_last = &amp;(head)-&gt;tqh_first;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<h3 id="在头部添加元素："><a href="#在头部添加元素：" class="headerlink" title="在头部添加元素："></a>在头部添加元素：</h3><pre><code>#define TAILQ_INSERT_HEAD(head, elm, field) do &#123;
        //elm指向下一个元素，即头元素。判断当前队列是否为空
        if (((elm)-&gt;field.tqe_next = (head)-&gt;tqh_first) != NULL)
                //非空，当前头元素指向上一个元素elm
                (head)-&gt;tqh_first-&gt;field.tqe_prev =
                    &amp;(elm)-&gt;field.tqe_next;
        else
                //为空，elm变成尾元素，于是指向尾元素
                (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;
        //elm变成头元素，于是指向头元素
        (head)-&gt;tqh_first = (elm);
        //elm指向上一个元素，这里时HEAD
        (elm)-&gt;field.tqe_prev = &amp;(head)-&gt;tqh_first;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<h3 id="在尾部添加元素"><a href="#在尾部添加元素" class="headerlink" title="在尾部添加元素"></a>在尾部添加元素</h3><pre><code>#define	TAILQ_INSERT_TAIL(head, elm, field) do &#123;
    //elm的指向下一个元素NULL
    (elm)-&gt;field.tqe_next = NULL;
    //elm的指向上一个元素，即当前尾元素
    (elm)-&gt;field.tqe_prev = (head)-&gt;tqh_last;
    //当前尾元素指向下一个元素elm
    *(head)-&gt;tqh_last = (elm);
    //elm变成尾元素，于是指向尾元素
    (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<h3 id="在指定元素后面添加元素"><a href="#在指定元素后面添加元素" class="headerlink" title="在指定元素后面添加元素"></a>在指定元素后面添加元素</h3><pre><code>#define	TAILQ_INSERT_AFTER(head, listelm, elm, field) do &#123;
    //elm指向listelm指向的下一个元素，并判断listelm是否是尾元素
    if (((elm)-&gt;field.tqe_next = (listelm)-&gt;field.tqe_next) != NULL)
        //不是，elm的下一个元素指向上一个元素elm
        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev =
            &amp;(elm)-&gt;field.tqe_next;
    else
        //是，elm变成尾元素，于是指向尾元素
        (head)-&gt;tqh_last = &amp;(elm)-&gt;field.tqe_next;
    //listelm指向下一个元素elm
    (listelm)-&gt;field.tqe_next = (elm);
    //elm指向上一个元素listelm
    (elm)-&gt;field.tqe_prev = &amp;(listelm)-&gt;field.tqe_next;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<blockquote>
<p>这跟<code>TAILQ_INSERT_HEAD</code>非常像，都需要判断下一个元素是否是NULL，据此决定更新是尾元素，还是下一个元素</p>
</blockquote>
<h3 id="在指定元素前面添加元素"><a href="#在指定元素前面添加元素" class="headerlink" title="在指定元素前面添加元素"></a>在指定元素前面添加元素</h3><pre><code>#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do &#123;
    //elm指向listelm指向的上一个元素
    (elm)-&gt;field.tqe_prev = (listelm)-&gt;field.tqe_prev;
    //elm指向下一个元素listelm
    (elm)-&gt;field.tqe_next = (listelm);
    //listelm的上一个元素指向下一个元素elm
    *(listelm)-&gt;field.tqe_prev = (elm);
    //listelm指向上一个元素elm
    (listelm)-&gt;field.tqe_prev = &amp;(elm)-&gt;field.tqe_next;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><pre><code>#define	TAILQ_REMOVE(head, elm, field) do &#123;
    //判断elm是否是尾元素
    if (((elm)-&gt;field.tqe_next) != NULL)
        //不是，elm的下一个元素指向上一个元素，即elm指向的上一个元素
        (elm)-&gt;field.tqe_next-&gt;field.tqe_prev =
            (elm)-&gt;field.tqe_prev;
    else
        //是，elm的上一个元素变成尾元素，更新尾元素
        (head)-&gt;tqh_last = (elm)-&gt;field.tqe_prev;
    //elm的上一个元素指向下一个元素，即elm的下一个元素
    *(elm)-&gt;field.tqe_prev = (elm)-&gt;field.tqe_next;
&#125; while (/*CONSTCOND*/0)
</code></pre>
<h3 id="正向遍历"><a href="#正向遍历" class="headerlink" title="正向遍历"></a>正向遍历</h3><pre><code>#define	TAILQ_FOREACH(var, head, field)
    //获取头元素，判断是否有下一个元素
    for ((var) = ((head)-&gt;tqh_first);
        (var);
        (var) = ((var)-&gt;field.tqe_next))
</code></pre>
<h3 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h3><pre><code>#define	TAILQ_FOREACH_REVERSE(var, head, headname, field)
    //获取尾元素，判断是否有上一个元素
    for ((var) = (*(((struct headname *)((head)-&gt;tqh_last))-&gt;tqh_last));
        (var);
        (var) = (*(((struct headname *)((var)-&gt;field.tqe_prev))-&gt;tqh_last)))
</code></pre>
<p>第一次看到这段代码的时，一头雾水，<code>tqh_last</code>后面又跟着一个<code>tqh_last</code>，what？反反复复看了几遍，渐渐就明白了——先看下HEAD和ENTRY的定义，不难发现它们在内存结构上是一样的。我们知道<code>tqh_last</code>是指向尾元素的<code>tqe_next</code>，强制转换后变成HEAD类型，第二个<code>tqh_last</code>实际上就是尾元素的<code>tqe_prev</code>指针，该指针中存放的是上一个元素<code>tqe_next</code>指针的地址，反引用后就成了尾元素的地址。</p>
<pre><code>struct name &#123;
        qual type *tqh_first;           /* 指向第一个元素 */
        qual type *qual *tqh_last;      /* 指向最后一个元素的next指针 */
&#125;

struct &#123;
        qual type *tqe_next;            /* 指向下一个元素 */
        qual type *qual *tqe_prev;      /* 指向上一个元素的next指针 */
&#125;
</code></pre>
<p>考虑一下反向遍历到最后一个元素，即头元素的时候，循环是如何终止的。此时<code>var</code>指向头元素，<code>tqe_prev</code>指向HEAD的<code>tqh_first</code>指针，如果指向NULL，那么就会出现<code>NULL-&gt;thq_last</code>。强制转换后，访问HEAD的<code>tqh_last</code>指针，该指针指向尾元素的<code>tqe_next</code>，我们知道尾元素作为最后一个元素指向NULL，反引用后就是NULL，循环终止。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>smilenceee</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="http://yoursite.com/queue-h%E4%B9%8B%E5%B0%BE%E9%98%9F%E5%88%97/">http://yoursite.com/queue-h%E4%B9%8B%E5%B0%BE%E9%98%9F%E5%88%97/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                
                     <p class="copyright-item">
                         <span>Slogan:</span>
                         <span>Do you believe in <strong>DESTINY</strong>?</span>
                     </p>
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tags/queue/"># queue</a>
                    
                        <a href="/tags/%E5%B0%BE%E9%98%9F%E5%88%97/"># 尾队列</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/ELK%E6%90%AD%E5%BB%BA/">ELK搭建</a>
            
            
            <a class="next" rel="next" href="/hive-map-%E5%B5%8C%E5%A5%97-map/">hive map 嵌套 map</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© smilenceee | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>